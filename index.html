<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2048 æ•¸å­—æŠ‘åˆ¶éŠæˆ² (AI å¢å¼·ç‰ˆ)</title>
    <style>
        /* å¼•å…¥ Inter å­—é«”ä½œç‚ºé€šç”¨å­—é«”ï¼Œæä¾›æ¸…æ™°çš„é¡¯ç¤ºæ•ˆæœ */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700;900&display=swap');

        :root {
            /* é¡è‰²è®Šé‡ */
            --color-bg-main: #fcfcfc;
            --color-grid-bg: #bbada0;
            --color-empty-cell: #cdc1b4;
            --color-ai-button: #5cb85c; /* ç¶ è‰²ï¼Œä»£è¡¨ç­–ç•¥ */
            --font-stack: 'Inter', system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            --border-radius-main: 8px;
            --spacing-unit: 12px;
        }

        body {
            font-family: var(--font-stack);
            background-color: var(--color-bg-main);
            color: #776e65;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            margin: 0;
            padding: var(--spacing-unit);
            box-sizing: border-box;
            user-select: none; /* é˜²æ­¢é¸æ“‡æ–‡å­— */
        }

        /* éŠæˆ²æ¨™é¡Œå’Œåˆ†æ•¸å€å¡Š */
        .header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            width: 100%;
            max-width: 500px;
            margin-bottom: var(--spacing-unit);
        }

        h1 {
            font-size: 3.5rem;
            font-weight: 900;
            color: #776e65;
            margin: 0;
            line-height: 1;
        }

        .score-container {
            text-align: right;
            line-height: 1;
        }

        .score-box {
            background-color: #bbada0;
            color: white;
            padding: 8px 16px;
            border-radius: var(--border-radius-main);
            font-size: 1.5rem;
            font-weight: 700;
            min-width: 80px;
            display: inline-block;
            margin-bottom: 4px; /* èˆ‡æŒ‰éˆ•ä¿æŒä¸€è‡´ */
        }

        .score-label {
            font-size: 0.8rem;
            font-weight: 700;
            text-transform: uppercase;
            color: #eee4da;
            display: block;
            margin-bottom: 4px;
        }

        /* AI ç­–ç•¥æŒ‰éˆ• */
        .strategy-container {
            width: 100%;
            max-width: 500px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-bottom: var(--spacing-unit);
        }
        
        #strategy-button {
            background-color: var(--color-ai-button);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: var(--border-radius-main);
            font-size: 1rem;
            font-weight: 700;
            cursor: pointer;
            transition: background-color 0.2s, transform 0.1s;
            box-shadow: 0 4px #3d7e3d;
        }

        #strategy-button:hover {
            background-color: #6ed16e;
        }
        #strategy-button:active {
            transform: translateY(2px);
            box-shadow: 0 2px #3d7e3d;
        }
        #strategy-button:disabled {
            background-color: #ccc;
            box-shadow: none;
            cursor: not-allowed;
        }

        #strategy-output {
            background-color: #fff8e1;
            border: 1px solid #ffecb3;
            color: #6d4c41;
            padding: 10px;
            border-radius: var(--border-radius-main);
            font-size: 0.9rem;
            min-height: 20px;
            transition: all 0.3s ease;
        }

        /* éŠæˆ²ä¸»å®¹å™¨ */
        .game-container {
            position: relative;
            background: var(--color-grid-bg);
            border-radius: var(--border-radius-main);
            padding: var(--spacing-unit);
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.2);
            touch-action: none; /* å…è¨±åœ¨è§¸æ‘¸è¨­å‚™ä¸Šé€²è¡Œæ»‘å‹• */
        }

        /* éŠæˆ²ç¶²æ ¼ */
        .grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            grid-template-rows: repeat(4, 1fr);
            gap: var(--spacing-unit);
        }

        .cell {
            width: 100px;
            height: 100px;
            background-color: var(--color-empty-cell);
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2rem;
            font-weight: 700;
            transition: 
                transform 0.2s ease-out, 
                opacity 0.2s ease-out,
                background-color 0.1s ease-in-out;
        }

        /* æ•¸å­—æ–¹å¡Šæ¨£å¼ (Tile) */
        .tile {
            position: absolute;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 100px;
            height: 100px;
            border-radius: 4px;
            color: white;
            font-size: 2rem;
            font-weight: 700;
            /* å‹•ç•«éæ¸¡ */
            transition: all 0.1s ease-in-out, transform 0.2s ease;
        }

        /* æ–¹å¡Šå€¼é…è‰² */
        .tile-2 { background: #eee4da; color: #776e65; }
        .tile-4 { background: #ede0c8; color: #776e65; }
        .tile-8 { background: #f2b179; }
        .tile-16 { background: #f59563; }
        .tile-32 { background: #f67c5f; }
        .tile-64 { background: #f65e3b; }
        .tile-128 { background: #edcf72; font-size: 1.6rem; }
        .tile-256 { background: #edcc61; font-size: 1.6rem; }
        .tile-512 { background: #edc850; font-size: 1.6rem; }
        .tile-1024 { background: #edc53f; font-size: 1.4rem; }
        .tile-2048 { background: #edc22e; font-size: 1.4rem; }
        .tile-super { background: #3c3a32; font-size: 1.2rem; }

        /* æ–°å‡ºç¾çš„æ–¹å¡Šå‹•ç•« */
        .tile-new {
            animation: popIn 0.15s ease-out;
        }

        @keyframes popIn {
            0% { transform: scale(0.5); opacity: 0.5; }
            100% { transform: scale(1); opacity: 1; }
        }

        /* éŠæˆ²ç‹€æ…‹è¦†è“‹å±¤ (Game Over / Win) */
        .overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(255, 255, 255, 0.9); /* ç¨å¾®ä¸é€æ˜ä¸€é» */
            border-radius: var(--border-radius-main);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 10;
            text-align: center;
            padding: var(--spacing-unit);
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease;
        }

        .overlay.visible {
            opacity: 1;
            visibility: visible;
        }

        .overlay h2 {
            font-size: 2.5rem; /* èª¿æ•´å¤§å°ä»¥å®¹ç´æ›´å¤šæ–‡å­— */
            color: #776e65;
            margin-bottom: var(--spacing-unit);
            line-height: 1.2;
        }

        .overlay p {
            font-size: 1.1rem;
            color: #8f7a66;
            margin-bottom: 20px;
            max-width: 80%;
        }

        .overlay button {
            background-color: #8f7a66;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            font-size: 1.2rem;
            font-weight: 700;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .overlay button:hover {
            background-color: #9f8a75;
        }

        .instructions {
            width: 100%;
            max-width: 500px;
            margin-top: var(--spacing-unit);
            font-size: 0.9rem;
            line-height: 1.4;
            color: #8f7a66;
            text-align: center;
        }

        /* éŸ¿æ‡‰å¼è¨­è¨ˆ */
        @media (max-width: 550px) {
            h1 { font-size: 2.5rem; }
            .score-box { font-size: 1.2rem; min-width: 60px; padding: 6px 12px; }
            .cell, .tile { width: 70px; height: 70px; font-size: 1.5rem; }
            .grid, .game-container { gap: 8px; padding: 8px; }
            .tile-128, .tile-256, .tile-512 { font-size: 1.4rem; }
            .tile-1024, .tile-2048 { font-size: 1.2rem; }
            .overlay h2 { font-size: 2rem; }
            .overlay p { font-size: 1rem; }
            #strategy-button { padding: 8px 15px; font-size: 0.9rem; }
        }

        @media (max-width: 400px) {
            .cell, .tile { width: 60px; height: 60px; font-size: 1.3rem; }
            .tile-128, .tile-256, .tile-512 { font-size: 1.2rem; }
            .tile-1024, .tile-2048 { font-size: 1rem; }
            .header { flex-direction: column; align-items: center; }
            .score-container { margin-top: 10px; }
        }
    </style>
</head>
<body>

    <div class="header">
        <h1>2048</h1>
        <div class="score-container">
            <span class="score-box" id="score-label">
                <span class="score-label">åˆ†æ•¸</span>
                <span id="score">0</span>
            </span>
        </div>
    </div>
    
    <!-- AI ç­–ç•¥å€å¡Š -->
    <div class="strategy-container">
        <button id="strategy-button" title="Ask Gemini for the optimal next move">âœ¨ è«‹æ±‚ AI ç­–ç•¥ âœ¨</button>
        <div id="strategy-output">
            AI ç­–ç•¥å»ºè­°å°‡é¡¯ç¤ºåœ¨é€™è£¡ã€‚
        </div>
    </div>
    <!-- çµæŸ AI ç­–ç•¥å€å¡Š -->

    <div class="game-container" id="game-container">
        <!-- 4x4 ç¶²æ ¼åº•å±¤ -->
        <div class="grid">
            <div class="cell"></div>
            <div class="cell"></div>
            <div class="cell"></div>
            <div class="cell"></div>
            <div class="cell"></div>
            <div class="cell"></div>
            <div class="cell"></div>
            <div class="cell"></div>
            <div class="cell"></div>
            <div class="cell"></div>
            <div class="cell"></div>
            <div class="cell"></div>
            <div class="cell"></div>
            <div class="cell"></div>
            <div class="cell"></div>
            <div class="cell"></div>
        </div>

        <!-- éŠæˆ²ç‹€æ…‹è¦†è“‹å±¤ -->
        <div class="overlay" id="overlay">
            <h2 id="overlay-message"></h2>
            <p id="ai-analysis" style="font-weight: 700;">åˆ†æä¸­...</p>
            <button id="restart-button">é‡æ–°é–‹å§‹</button>
        </div>

        <!-- æ–¹å¡Šå°‡åœ¨é€™è£¡å‹•æ…‹ç”Ÿæˆ -->
    </div>

    <div class="instructions">
        ä½¿ç”¨éµç›¤æ–¹å‘éµ (â†‘ â†“ â† â†’) æˆ–åœ¨æ‰‹æ©Ÿä¸Šæ»‘å‹•ä»¥ç§»å‹•æ–¹å¡Šã€‚
    </div>

    <script>
        const GRID_SIZE = 4;
        const TILE_CONTAINER = document.getElementById('game-container');
        const SCORE_ELEM = document.getElementById('score');
        const OVERLAY = document.getElementById('overlay');
        const OVERLAY_MESSAGE = document.getElementById('overlay-message');
        const RESTART_BUTTON = document.getElementById('restart-button');
        const STRATEGY_BUTTON = document.getElementById('strategy-button');
        const STRATEGY_OUTPUT = document.getElementById('strategy-output');
        const AI_ANALYSIS_ELEM = document.getElementById('ai-analysis');

        let board = [];
        let score = 0;
        let isGameOver = false;
        let isGameWon = false;
        let isMoving = false;
        let highestTile = 0; // è¿½è¹¤æœ€é«˜åˆ†æ•¸æ–¹å¡Š

        // è§¸æ‘¸äº‹ä»¶çš„èµ·å§‹åæ¨™
        let touchStartX = 0;
        let touchStartY = 0;
        const SWIPE_THRESHOLD = 50;
        
        // --- Gemini API è¨­ç½® ---
        const API_KEY = ""; // Canvas é‹è¡Œæ™‚æœƒæä¾›
        const API_URL = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${API_KEY}`;
        
        /**
         * å°‡ 4x4 æ£‹ç›¤è½‰æ›ç‚ºä¸€å€‹æ˜“æ–¼ LLM è§£æçš„å­—ç¬¦ä¸²æ ¼å¼
         * @returns {string} æ£‹ç›¤ç‹€æ…‹å­—ç¬¦ä¸²
         */
        function formatBoardForLLM() {
            return JSON.stringify(board).replace(/\[/g, '(').replace(/\]/g, ')');
        }

        /**
         * åŸ·è¡Œ Gemini API å‘¼å«ï¼Œå¸¶æœ‰æŒ‡æ•¸é€€é¿æ©Ÿåˆ¶
         * @param {string} systemInstruction - çµ¦ LLM çš„ç³»çµ±æŒ‡ä»¤
         * @param {string} userQuery - å‚³éçµ¦ LLM çš„ç”¨æˆ¶æŸ¥è©¢
         * @param {number} retryCount - ç•¶å‰é‡è©¦æ¬¡æ•¸
         * @returns {Promise<string>} ä¾†è‡ª LLM çš„å›æ‡‰æ–‡æœ¬
         */
        async function callGeminiAPI(systemInstruction, userQuery, retryCount = 0) {
            const MAX_RETRIES = 3;
            const delay = Math.pow(2, retryCount) * 1000;

            const payload = {
                contents: [{ parts: [{ text: userQuery }] }],
                systemInstruction: { parts: [{ text: systemInstruction }] },
            };

            try {
                const response = await fetch(API_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    if (response.status === 429 && retryCount < MAX_RETRIES) {
                        console.warn(`API Rate limit exceeded, retrying in ${delay / 1000}s...`);
                        await new Promise(resolve => setTimeout(resolve, delay));
                        return callGeminiAPI(systemInstruction, userQuery, retryCount + 1);
                    }
                    throw new Error(`API call failed with status: ${response.status}`);
                }

                const result = await response.json();
                const text = result.candidates?.[0]?.content?.parts?.[0]?.text || "ç„¡æ³•ç²å– AI å›æ‡‰ã€‚";
                return text;

            } catch (error) {
                console.error("Gemini API Error:", error);
                return `API éŒ¯èª¤: ${error.message}`;
            }
        }

        /**
         * è«‹æ±‚ AI æä¾›ç­–ç•¥å»ºè­°
         */
        STRATEGY_BUTTON.addEventListener('click', async () => {
            if (isGameOver || isMoving) return;

            STRATEGY_BUTTON.disabled = true;
            STRATEGY_OUTPUT.textContent = "AI æ­£åœ¨åˆ†ææ£‹ç›¤... (æ€è€ƒä¸­)";
            
            const boardState = formatBoardForLLM();
            const systemPrompt = "ä½ æ˜¯ä¸€ä½ 2048 éŠæˆ²å°ˆå®¶ç­–ç•¥å¸«ã€‚ä½ çš„ä¸»è¦ç›®æ¨™æ˜¯æä¾›ç°¡æ½”ã€æˆ°è¡“æ€§çš„å»ºè­°ï¼ŒåŒ…å«**å–®ä¸€**æœ€ä½³ç§»å‹•æ–¹å‘å’Œç°¡çŸ­ç†ç”±ã€‚";
            const userQuery = `åˆ†æç•¶å‰çš„ 2048 éŠæˆ²æ£‹ç›¤ç‹€æ…‹ï¼š${boardState}ã€‚å»ºè­°**å–®ä¸€**æœ€ä½³çš„ä¸‹ä¸€æ­¥ç§»å‹•æ–¹å‘ (UP, DOWN, LEFT, æˆ– RIGHT) ä¸¦æä¾›ä¸€å€‹ç°¡çŸ­çš„ (æœ€å¤š 30 å€‹ä¸­æ–‡å­—) ç†ç”±ï¼Œç›®æ¨™æ˜¯è¡æ“Šé«˜åˆ†ã€‚`;

            const strategy = await callGeminiAPI(systemPrompt, userQuery);

            STRATEGY_OUTPUT.textContent = strategy;
            STRATEGY_BUTTON.disabled = false;
        });

        // --- åˆå§‹åŒ–éŠæˆ² ---

        function setupGame() {
            // æ¸…ç©ºèˆŠçš„æ–¹å¡Š
            const tiles = document.querySelectorAll('.tile');
            tiles.forEach(tile => tile.remove());

            board = Array(GRID_SIZE).fill(0).map(() => Array(GRID_SIZE).fill(0));
            score = 0;
            isGameOver = false;
            isGameWon = false;
            isMoving = false;
            highestTile = 0; // é‡ç½®æœ€é«˜æ–¹å¡Š

            updateScore(0);
            OVERLAY.classList.remove('visible');
            STRATEGY_OUTPUT.textContent = "AI ç­–ç•¥å»ºè­°å°‡é¡¯ç¤ºåœ¨é€™è£¡ã€‚";
            
            addRandomTile();
            addRandomTile();
            updateUI();
        }

        // --- æ ¸å¿ƒé‚è¼¯ï¼šæ–°å¢æ–¹å¡Š ---

        function addRandomTile() {
            if (!hasEmptyCell()) return;

            let row, col;
            do {
                row = Math.floor(Math.random() * GRID_SIZE);
                col = Math.floor(Math.random() * GRID_SIZE);
            } while (board[row][col] !== 0);

            // 90% çš„æ©Ÿç‡æ˜¯ 2ï¼Œ10% æ˜¯ 4
            board[row][col] = Math.random() < 0.9 ? 2 : 4;
        }

        function hasEmptyCell() {
            return board.some(row => row.includes(0));
        }

        // --- æ ¸å¿ƒé‚è¼¯ï¼šç§»å‹•èˆ‡åˆä½µ ---

        // ç²å–ç¶²æ ¼å–®å…ƒçš„ä½ç½®ä¿¡æ¯ï¼Œç”¨æ–¼å®šä½æ–¹å¡Š
        function getCellPosition(row, col) {
            const containerRect = TILE_CONTAINER.getBoundingClientRect();
            // å¾ CSS ä¸­ç²å–é–“è·ï¼ˆ12pxï¼‰
            const gap = parseFloat(getComputedStyle(TILE_CONTAINER).padding) / GRID_SIZE; 
            const cellWidth = (containerRect.width - (GRID_SIZE + 1) * 12) / GRID_SIZE; 

            // è¨ˆç®—åŸºæ–¼å®¹å™¨å·¦ä¸Šè§’çš„åç§»é‡ (padding/gap ç‚º 12px)
            const x = 12 + col * (cellWidth + 12);
            const y = 12 + row * (cellWidth + 12);

            return { x, y, width: cellWidth };
        }

        function filterZeros(arr) {
            return arr.filter(val => val !== 0);
        }

        function mergeTiles(arr) {
            const newArr = filterZeros(arr);
            let merged = false;
            for (let i = 0; i < newArr.length - 1; i++) {
                if (newArr[i] === newArr[i + 1]) {
                    const mergedValue = newArr[i] * 2;
                    newArr[i] = mergedValue;
                    newArr[i + 1] = 0;
                    updateScore(score + mergedValue);
                    if (mergedValue > highestTile) {
                        highestTile = mergedValue; // æ›´æ–°æœ€é«˜æ–¹å¡Š
                    }
                    merged = true;
                }
            }
            // å†æ¬¡éæ¿¾ä¸¦å¡«å……é›¶
            const finalArr = filterZeros(newArr);
            while (finalArr.length < GRID_SIZE) {
                finalArr.push(0);
            }
            return { array: finalArr, merged };
        }

        // è™•ç†å–®å€‹æ–¹å‘çš„ç§»å‹• (0: å·¦, 1: å³, 2: ä¸Š, 3: ä¸‹)
        function move(direction) {
            if (isMoving || isGameOver) return;
            isMoving = true;
            STRATEGY_OUTPUT.textContent = "AI ç­–ç•¥å»ºè­°å°‡é¡¯ç¤ºåœ¨é€™è£¡ã€‚"; // æ¸…é™¤èˆŠå»ºè­°

            let boardChanged = false;
            let newBoard = Array(GRID_SIZE).fill(0).map(() => Array(GRID_SIZE).fill(0));
            
            // åŸ·è¡Œç§»å‹•é‚è¼¯
            for (let i = 0; i < GRID_SIZE; i++) {
                let line = [];
                if (direction === 0 || direction === 1) { // å·¦å³ç§»å‹• (è™•ç†è¡Œ)
                    line = board[i];
                } else { // ä¸Šä¸‹ç§»å‹• (è™•ç†åˆ—)
                    line = board.map(row => row[i]);
                }

                // åŸ·è¡Œåˆä½µ
                let { array: mergedLine, merged: lineMerged } = direction === 0 || direction === 2 
                    ? mergeTiles(line)  // å·¦/ä¸Š (æ­£å‘åˆä½µ)
                    : mergeTiles([...line].reverse()); // å³/ä¸‹ (åå‘åˆä½µï¼Œç„¶å¾Œåè½‰å›ä¾†)

                if (direction === 1 || direction === 3) {
                    mergedLine = mergedLine.reverse(); // æ¢å¾©åˆ°æ­£ç¢ºçš„é †åº
                }

                // æª¢æŸ¥æ˜¯å¦æœ‰è®ŠåŒ–
                if (JSON.stringify(line) !== JSON.stringify(mergedLine) || lineMerged) {
                    boardChanged = true;
                }

                // è¨­ç½®æ–°æ¿ç‹€æ…‹
                for (let j = 0; j < GRID_SIZE; j++) {
                    const newValue = mergedLine[j];

                    if (direction === 0 || direction === 1) {
                        newBoard[i][j] = newValue; // è¨­ç½®æ–°è¡Œ
                    } else {
                        newBoard[j][i] = newValue; // è¨­ç½®æ–°åˆ—
                    }
                }
            }
            
            if (boardChanged) {
                board = newBoard;
                addRandomTile();
                updateUI();
                checkGameStatus();
            }

            // å³ä½¿æœ‰è®ŠåŒ–ï¼Œä¹Ÿéœ€è¦çŸ­æš«å»¶é²ä¾†è®“æ–°æ–¹å¡Š 'pop in'
            setTimeout(() => {
                isMoving = false;
            }, 100);
        }

        // --- UI æ¸²æŸ“ ---

        function getTileColorClass(value) {
            if (value <= 2048) {
                return `tile-${value}`;
            }
            return 'tile-super';
        }

        function updateUI() {
            // 1. ç§»é™¤èˆŠçš„æ–¹å¡Š
            const oldTiles = document.querySelectorAll('.tile');
            oldTiles.forEach(tile => tile.remove());

            // 2. é‡æ–°ç¹ªè£½æ‰€æœ‰æ–¹å¡Š
            for (let r = 0; r < GRID_SIZE; r++) {
                for (let c = 0; c < GRID_SIZE; c++) {
                    const value = board[r][c];
                    if (value !== 0) {
                        const pos = getCellPosition(r, c);

                        const tile = document.createElement('div');
                        tile.className = `tile ${getTileColorClass(value)}`;
                        tile.textContent = value;
                        
                        // è¨­ç½®ä½ç½® (ä½¿ç”¨ transform å¯¦ç¾ç¡¬æ€§å®šä½å’Œå‹•ç•«)
                        tile.style.transform = `translate(${pos.x}px, ${pos.y}px)`;
                        tile.style.width = `${pos.width}px`;
                        tile.style.height = `${pos.width}px`;
                        
                        tile.setAttribute('data-row', r);
                        tile.setAttribute('data-col', c);
                        tile.setAttribute('data-value', value);

                        tile.classList.add('tile-new');
                        
                        TILE_CONTAINER.appendChild(tile);
                        
                        // æª¢æŸ¥å‹åˆ©
                        if (value === 2048 && !isGameWon) {
                            isGameWon = true;
                            // å»¶é²å±•ç¤ºå‹åˆ©è¨Šæ¯ï¼Œè®“æ–¹å¡Šå‹•ç•«å®Œæˆ
                            setTimeout(() => {
                                checkGameStatus();
                            }, 500);
                        }
                    }
                }
            }
        }

        // æ›´æ–°åˆ†æ•¸ UI
        function updateScore(newScore) {
            score = newScore;
            SCORE_ELEM.textContent = score;
        }

        // --- éŠæˆ²ç‹€æ…‹æª¢æŸ¥ ---
        async function checkGameStatus() {
            if (isGameWon) {
                OVERLAY_MESSAGE.textContent = "æ­å–œï¼æ‚¨é”åˆ°äº† 2048ï¼";
                AI_ANALYSIS_ELEM.textContent = "ğŸ‰ éŠæˆ²ç²å‹ï¼é€™æ˜¯éå¸¸äº†ä¸èµ·çš„æˆå°±ï¼";
                OVERLAY.classList.add('visible');
                return;
            }

            if (hasEmptyCell()) {
                return; // é‚„æœ‰ç©ºä½ï¼Œç¹¼çºŒéŠæˆ²
            }

            // æª¢æŸ¥æ˜¯å¦é‚„æœ‰ä»»ä½•åˆä½µçš„å¯èƒ½æ€§
            for (let r = 0; r < GRID_SIZE; r++) {
                for (let c = 0; c < GRID_SIZE; c++) {
                    const val = board[r][c];
                    
                    // æª¢æŸ¥å³å´
                    if (c < GRID_SIZE - 1 && board[r][c + 1] === val) return;
                    // æª¢æŸ¥ä¸‹æ–¹
                    if (r < GRID_SIZE - 1 && board[r + 1][c] === val) return;
                }
            }

            // æ—¢æ²’æœ‰ç©ºä½ï¼Œä¹Ÿæ²’æœ‰å¯åˆä½µçš„ï¼ŒéŠæˆ²çµæŸ
            isGameOver = true;
            OVERLAY_MESSAGE.textContent = "éŠæˆ²çµæŸï¼æ²’æœ‰æ›´å¤šç§»å‹•äº†ã€‚";
            
            // âœ¨ å‘¼å« AI é€²è¡ŒéŠæˆ²åˆ†æ
            AI_ANALYSIS_ELEM.textContent = "âœ¨ AI æ­£åœ¨åˆ†ææ‚¨çš„è¡¨ç¾...";
            
            const boardState = formatBoardForLLM();
            const systemPrompt = "ä½ æ˜¯ä¸€ä½ç†±æƒ…ä¸”é¼“å‹µäººçš„éŠæˆ²åˆ†æå¸«ã€‚æä¾›ä¸€ä»½ç°¡çŸ­çš„è¡¨ç¾åˆ†æï¼ˆ50å€‹ä¸­æ–‡å­—å…§ï¼‰ï¼Œä¸¦çµ¦å‡ºä¸€å€‹æˆ°è¡“æŠ€å·§ï¼Œå¹«åŠ©ç©å®¶åœ¨ä¸‹ä¸€æ¬¡å˜—è©¦ä¸­é€²æ­¥ã€‚";
            const userQuery = `ç©å®¶ä»¥åˆ†æ•¸ ${score} çµæŸäº†éŠæˆ²ï¼Œä¸¦é”åˆ°äº†æœ€é«˜çš„æ–¹å¡Š ${highestTile}ã€‚æœ€çµ‚æ£‹ç›¤ç‹€æ…‹ç‚ºï¼š${boardState}ã€‚è«‹æä¾›ä¸€ä»½é¼“å‹µæ€§çš„ç¸½çµå’Œä¸€å€‹æˆ°è¡“æç¤ºã€‚`;
            
            const analysis = await callGeminiAPI(systemPrompt, userQuery);
            AI_ANALYSIS_ELEM.textContent = `âœ¨ AI åˆ†æï¼š${analysis}`;
            
            OVERLAY.classList.add('visible');
        }

        // --- äº‹ä»¶è™•ç†ï¼šéµç›¤ ---

        document.addEventListener('keydown', (e) => {
            if (isGameOver || isMoving) return;

            switch (e.key) {
                case 'ArrowLeft':
                    move(0); // å·¦
                    break;
                case 'ArrowRight':
                    move(1); // å³
                    break;
                case 'ArrowUp':
                    move(2); // ä¸Š
                    break;
                case 'ArrowDown':
                    move(3); // ä¸‹
                    break;
                default:
                    return; // å¿½ç•¥å…¶ä»–éµ
            }
            e.preventDefault(); // é˜²æ­¢æ»¾å‹•é é¢
        });

        // --- äº‹ä»¶è™•ç†ï¼šè§¸æ‘¸/æ»‘å‹• (é©ç”¨æ–¼æ‰‹æ©Ÿ) ---

        TILE_CONTAINER.addEventListener('touchstart', (e) => {
            if (isGameOver || isMoving) return;
            touchStartX = e.touches[0].clientX;
            touchStartY = e.touches[0].clientY;
            e.preventDefault();
        }, { passive: false });

        TILE_CONTAINER.addEventListener('touchend', (e) => {
            if (isGameOver || isMoving || !touchStartX) return;

            const touchEndX = e.changedTouches[0].clientX;
            const touchEndY = e.changedTouches[0].clientY;

            const dx = touchEndX - touchStartX;
            const dy = touchEndY - touchStartY;

            const absDx = Math.abs(dx);
            const absDy = Math.abs(dy);

            if (Math.max(absDx, absDy) < SWIPE_THRESHOLD) {
                // æ»‘å‹•è·é›¢å¤ªçŸ­
                return;
            }

            // åˆ¤æ–·æ–¹å‘
            if (absDx > absDy) {
                // å·¦å³æ»‘å‹•
                if (dx > 0) move(1); // å³
                else move(0); // å·¦
            } else {
                // ä¸Šä¸‹æ»‘å‹•
                if (dy > 0) move(3); // ä¸‹
                else move(2); // ä¸Š
            }

            // é‡ç½®åæ¨™
            touchStartX = 0;
            touchStartY = 0;
        });

        // --- è¨­ç½®èˆ‡å•Ÿå‹• ---
        
        // é‡æ–°é–‹å§‹æŒ‰éˆ•
        RESTART_BUTTON.addEventListener('click', setupGame);

        // ç¢ºä¿åœ¨é é¢åŠ è¼‰å®Œæˆå¾Œè¨ˆç®—å–®å…ƒæ ¼å°ºå¯¸ä¸¦å•Ÿå‹•éŠæˆ²
        window.onload = function() {
            setupGame();
            
            // ç›£è½çª—å£å¤§å°æ”¹è®Šä»¥é‡æ–°è¨ˆç®—æ–¹å¡Šä½ç½®ï¼ˆéŸ¿æ‡‰å¼ï¼‰
            window.addEventListener('resize', updateUI); 
        };
    </script>
</body>
</html>
